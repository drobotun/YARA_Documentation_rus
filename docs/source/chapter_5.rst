.. _label_chapter_5:

Запуск YARA из командной строки
===============================


Чтобы вызвать YARA, вам понадобятся две вещи: файл с правилами (``RULES_FILE``), которые вы хотите использовать (либо в исходном коде, либо в скомпилированной форме), и цель для сканирования (``TARGET``). Целью может быть файл, папка или процесс.

.. code-block:: bash

	yara [OPTIONS] RULES_FILE TARGET

``RULES_FILE`` может быть передан непосредственно в форме исходного кода или может быть предварительно скомпилирован с помощью инструмента ``yarac``. Вы можете предпочесть использовать свои правила в скомпилированной форме, если вы собираетесь вызывать YARA несколько раз с одними и теми же правилами. Таким образом, вы сэкономите время, потому что для YARA быстрее загружать скомпилированные правила, заново чем компилировать одни и те же правила.

Вы также можете передать несколько исходных файлов в ``yara``, как в следующем примере:

.. code-block:: bash

	yara [OPTIONS] RULES_FILE_1 RULES_FILE_2 RULES_FILE_3 TARGET

Однако обратите внимание, что это работает только для правил в исходной форме. При вызове YARA с скомпилированными правилами принимается только один файл с правилами.

В приведенном выше примере все правила имеют одно и то же пространство имен по умолчанию, что означает, что идентификаторы правил должны быть уникальными среди всех файлов. Однако можно указать пространство имен для отдельных файлов. Например:

.. code-block:: bash

	yara [OPTIONS] namespace1:RULES_FILE_1 RULES_FILE_2 RULES_FILE_3 TARGET

В этом случае ``RULE_FILE_1`` использует пространство имен ``namespace1``, а ``rules_file_2`` и ``RULES_FILE_3`` используют пространство имен по умолчанию.

Во всех случаях правила будут применяться к цели, указанной в качестве последнего аргумента для YARA, если это путь к каталогу, то все файлы, содержащиеся в нем, будут проверены. По умолчанию YARA не сканирует каталоги рекурсивно, для этого можно использовать опцию ``-r``.

Доступные опции:

**-t** \<tag> --tag=\<tag>

Вывод правила с тегом \<tag> и игнорирование остальных правил.

*****

**-i** \<identifier> --identifier=\<identifier>

Вывод правила с именем \<identifier> и игнорирование остальных правил.

*****

**-c** --count

Вывод только нужного количества совпадений.

*****

**-n**

Печатать только невыполненных правил (отрицание).

*****

**-D** --print-module-data

Вывод данных модуля.

*****

**-g** --print-tags

Вывод тегов.

*****

**-m** --print-meta

Вывод метаданных.

*****

**-s** --print-strings

Вывод совпадающих строк.

*****

**-L** --print-string-length

Вывод длины совпадающих строк.

*****

**-e** --print-namespace

Вывод пространства имен правил.

*****

**-p** \<number> --threads=\<number>

Использование указанного числа потоков ``<number>`` для сканирования каталога.

*****

**-l** \<number> --max-rules=\<number>

Прервать сканирование после совпадения нескольких ``<number>`` правил.

*****

**-a** \<seconds> --timeout=\<seconds>

Прервать сканирование по истечении нескольких ``<seconds>`` секунд.

*****

**-k** \<slots> --stack-size=\<slots>

Выделение стека нужного размер для необходимого количества слотов ``<slots>``. По умолчанию: 16384. Это позволит использовать более объемные правила, хотя и с большим объемом памяти.

*****

Добавлено в версии 3.5.0.

**--max-strings-per-rule=<number>**

Установка максимального числа строк в правиле (по умолчанию=10000). Если в правиле больше указанного числа строк, возникает ошибка.

*****

Добавлено в версии 3.7.0.

**-d** \<identifier>=\<value>

Определить внешнюю переменную.

*****

**-x** \<module>=\<file>

Передать содержимое файла ``<file>`` в качестве дополнительных данных в модуль ``<module>``.

*****

**-r** --recursive

Рекурсивное сканирование каталога.

*****

**-f** --fast-scan

Режим быстрого соответствия.

*****

**-w** --no-warnings

Отключить предупреждения

*****

**--fail-on-warnings**

Обрабатывать предупреждения как ошибки. Не имеет эффекта, если используется с ``--no-warnings``.

*****

**-v** --version

Показать информацию о версии.

*****

**-h** --help

Показать справку.

*****

Вот несколько примеров:

Применить правило в ``/foo/bar/rules`` ко всем файлам в текущем каталоге. Подкаталоги не сканируются:

.. code-block:: bash

	yara /foo/bar/rules

Применить правила в ``/foo/bar/rules`` к ``bazfile``. Только отчеты о правилах, помеченных как ``Packer`` или ``Compiler``:

.. code-block:: bash

	yara -t Packer -t Compiler /foo/bar/rules bazfile

Сканирование всех файлов в каталоге ``/foo`` и его подкаталогах:

.. code-block:: bash

	yara -r /foo

Определение трех внешних переменных ``mybool``, ``myint`` и ``mystring``:

.. code-block:: bash

	yara -d mybool=true -d myint=5 -d mystring="my string" /foo/bar/rules bazfile

Применить правила в ``/foo/bar/rules`` для ``bazfile`` при передаче содержимого ``cuckoo_json_report`` к модулю ``cuckoo``:

.. code-block:: bash

	yara -x cuckoo=cuckoo_json_report /foo/bar/rules bazfile
